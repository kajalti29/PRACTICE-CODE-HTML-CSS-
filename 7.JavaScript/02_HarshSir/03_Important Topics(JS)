Important Topics:-

Scope:- determines where a variable is accessible in your code.
Scope ‡§Ø‡§π ‡§¨‡§§‡§æ‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§ï‡•ã‡§à variable/code ‡§ï‡§π‡§æ‡§Å ‡§∏‡•á ‡§è‡§ï‡•ç‡§∏‡•á‡§∏ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§

Types of Scope:-
1.Global Scope
2.Local Scope(Function Scope)
3.Block Scope

1.Global Scope:-Variables declared outside of any function have global. Accessible anywhere in the code.
(‡§Ö‡§ó‡§∞ ‡§ï‡•ã‡§à variable function ‡§ï‡•á ‡§¨‡§æ‡§π‡§∞ declare ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à ‡§§‡•ã ‡§µ‡§π ‡§∏‡§æ‡§∞‡•á ‡§ï‡•ã‡§° ‡§Æ‡•á‡§Ç accessible ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§)

var name = "Kajal"; // Global Scope
function greet() {
    console.log(name); // Accessible here
}
greet();
console.log(name); // Accessible here too


2.Function Scope (Local Scope):-Variables declared inside a function are only accessible within that function.(‡§ú‡•ã variable function ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ declare ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à, ‡§µ‡§π ‡§ï‡•á‡§µ‡§≤ ‡§â‡§∏‡•Ä function ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ accessible ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§)

function greet() {
    var msg = "Hello!";
    console.log(msg); // Works
}
greet();
console.log(msg); // Error! msg is not defined

3.Block Scope:-Introduced in ES6 with let and const.
  Variables are only accessible inside the block { } they are declared in.


if (true) {
    let age = 25;
    const city = "Delhi";
    console.log(age, city); // ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡•á‡§ó‡§æ
}
console.log(age); // Error! age defined ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à
console.log(city); // Error! city defined ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à


4.Hoisting in JavaScript:-

Hoisting is JavaScript‚Äôs behavior of moving variable and function declarations to the top of their scope before code execution.

Key Points:

Only declarations are hoisted, not initializations.

var is hoisted and initialized as undefined.

### **1Ô∏è‚É£ Variable Hoisting**

* **var** ‚Üí ‡§ï‡•á‡§µ‡§≤ declaration hoist ‡§π‡•ã‡§§‡•Ä ‡§π‡•à, **initialization ‡§®‡§π‡•Ä‡§Ç**‡•§
  Access ‡§ï‡§∞‡§®‡•á ‡§™‡§∞ declaration ‡§∏‡•á ‡§™‡§π‡§≤‡•á ‚Üí `undefined`

```javascript
console.log(a); // undefined
var a = 5;
```

* **let ‡§î‡§∞ const** ‚Üí hoisted ‡§§‡•ã ‡§π‡•ã‡§§‡•Ä ‡§π‡•à‡§Ç ‡§≤‡•á‡§ï‡§ø‡§® **Temporal Dead Zone (TDZ)** ‡§Æ‡•á‡§Ç ‡§∞‡§π‡§§‡•Ä ‡§π‡•à‡§Ç‡•§ Declaration ‡§∏‡•á ‡§™‡§π‡§≤‡•á access ‚Üí `ReferenceError`

```javascript
console.log(b); // ReferenceError
let b = 10;
```

---

### **2Ô∏è‚É£ Function Hoisting**

* **Function Declaration** ‚Üí ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π hoist ‡§π‡•ã ‡§ú‡§æ‡§§‡•Ä ‡§π‡•à‡•§ Call ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à declaration ‡§∏‡•á ‡§™‡§π‡§≤‡•á‡•§

greet(); // "Hello"
function greet() { console.log("Hello"); 

}

* **Function Expression** ‚Üí ‡§ï‡•á‡§µ‡§≤ variable hoist ‡§π‡•ã‡§§‡§æ ‡§π‡•à, function ‡§®‡§π‡•Ä‡§Ç‡•§ Call ‡§ï‡§∞‡§®‡•á ‡§™‡§∞ **TypeError** ‡§Ü‡§§‡•Ä ‡§π‡•à‡•§


sayHi(); // TypeError
var sayHi = function() { console.log("Hi");
 };



*Closure:-
        ‚ÄúA closure is a function that remembers its lexical scope, even when it is executed outside of that scope.‚Äù(‚ÄúClosure ‡§è‡§ï ‡§ê‡§∏‡§æ function ‡§π‡•à ‡§ú‡•ã ‡§Ö‡§™‡§®‡•á lexical scope (‡§Ø‡§æ‡§®‡§ø ‡§ú‡§ø‡§∏ ‡§ú‡§ó‡§π ‡§™‡§∞ ‡§µ‡•ã ‡§¨‡§®‡§æ ‡§•‡§æ, ‡§â‡§∏‡§ï‡•á variables ‡§î‡§∞ environment) ‡§ï‡•ã ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡§§‡§æ ‡§π‡•à, ‡§≠‡§≤‡•á ‡§π‡•Ä ‡§â‡§∏‡•á ‡§â‡§∏ scope ‡§ï‡•á ‡§¨‡§æ‡§π‡§∞ execute ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§è‡•§‚Äù)

Use of Closure:-
Closure ‡§ï‡§æ use private data ‡§¨‡§®‡§æ‡§®‡•á, state ‡§ï‡•ã preserve ‡§ï‡§∞‡§®‡•á, callbacks/event handlers ‡§Æ‡•á‡§Ç values ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡§®‡•á ‡§î‡§∞ modular code ‡§≤‡§ø‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à‡•§


Outer Function ‡§ï‡§æ ‡§Æ‡§§‡§≤‡§¨:-
.‡§ú‡§¨ ‡§π‡§Æ ‡§è‡§ï function ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§¶‡•Ç‡§∏‡§∞‡§æ function ‡§¨‡§®‡§æ‡§§‡•á ‡§π‡•à‡§Ç:
.‡§¨‡§æ‡§π‡§∞ ‡§µ‡§æ‡§≤‡§æ function üëâ Outer Function
.‡§Ö‡§Ç‡§¶‡§∞ ‡§µ‡§æ‡§≤‡§æ function üëâ Inner Function

üëâ ‡§î‡§∞ ‡§ú‡§¨ inner function, outer function ‡§ï‡•á variables ‡§ï‡•ã access ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, ‡§§‡•ã ‡§á‡§∏‡•á Closure ‡§ï‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§

Closure Code ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á Steps:-

1.‡§è‡§ï Outer Function ‡§¨‡§®‡§æ‡§ì‡•§
2.Outer function ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§ï‡•ã‡§à variable declare ‡§ï‡§∞‡•ã‡•§
3.Outer function ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§è‡§ï Inner function ‡§¨‡§®‡§æ‡§ì‡•§
4.Inner function ‡§â‡§∏ variable ‡§ï‡•ã use ‡§ï‡§∞‡•á‡•§
5.Inner function ‡§ï‡•ã return ‡§ï‡§∞ ‡§¶‡•ã‡•§
6.Outer function ‡§ï‡•ã call ‡§ï‡§∞‡§ï‡•á result use ‡§ï‡§∞‡•ã‡•§

#Basic Closure:-
function outer() {          // Step 1
    let a = 10;             // Step 2 (outer variable)

    function inner() {      // Step 3
        console.log(a);     // Step 4 (use outer variable)
    }

    return inner;           // Step 5
}

let myFunc = outer();       // Step 6
myFunc();  // Output: 10



1. Objects in JavaScript

üëâ Objects basically key‚Äìvalue pairs hote ‡§π‡•à‡§Ç.
‡§π‡§∞ key ek property ‡§Ø‡§æ method ‡§π‡•ã ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à‡•§

let person = {
    name: "Kajal",
    age: 22,
    city: "Indore",
    
    // Method (function inside object)
    greet: function() {
        return `Hello, my name is ${this.name}`;
    }
};

console.log(person.name);   // Property access ‚Üí Kajal
console.log(person.greet()); // Method call ‚Üí Hello, my name is Kajal




#Methods of Objects:-

Object methods :- keys(), values(), entries(), assign() etc.
Example:-
let student = {
    id: 101,
    name: "Aman"
};

// üîπ Object.keys() ‚Üí sabhi keys return karega
      console.log(Object.keys(student));  
; // ["id", "name"]

// üîπ Object.values() ‚Üí sabhi values return karega
      console.log(Object.values(student));  
;   [101, "Aman"]

// üîπ Object.entries() ‚Üí [key, value] pairs return karega
      console.log(Object.entries(student));  
; // [["id", 101], ["name", "Aman"]]

// üîπ Object.assign() ‚Üí ek object ke properties dusre me copy karega
let extra = { age: 20 };
Object.assign(student, extra);
console.log(student); 
; // { id: 101, name: "Aman", age: 20 }



## 3. **Regex (Regular Expressions) in JavaScript**

üëâ Regex ek **pattern** hai jo string ke andar **search, match, validate** karne ke liye use hota hai.

### Syntax:

```javascript
let pattern = /abc/;   // literal notation
let pattern2 = new RegExp("abc"); // constructor notation
```

---

### Common Methods with Regex

```javascript
let str = "My number is 9876543210";

// üîπ test() ‚Üí true/false return karega
let regex1 = /\d{10}/;   // 10 digits ka pattern
console.log(regex1.test(str));  
// true

// üîπ match() ‚Üí matched value return karega
let result = str.match(/\d{10}/);
console.log(result[0]);  
// 9876543210

// üîπ replace() ‚Üí match hone par replace karega
let newStr = str.replace(/\d{10}/, "**********");
console.log(newStr); 
// My number is **********
```

---

### Some Useful Regex Patterns

* `\d` ‚Üí digit (0-9)
* `\w` ‚Üí word character (a-z, A-Z, 0-9, \_)
* `\s` ‚Üí whitespace (space, tab, newline)
* `+` ‚Üí one or more
* `*` ‚Üí zero or more
* `{n}` ‚Üí exactly n times
* `^` ‚Üí start of string
* `$` ‚Üí end of string

#### Example:

```javascript
let email = "test123@gmail.com";
let emailPattern = /^[\w.-]+@[a-zA-Z]+\.[a-z]{2,3}$/;

console.log(emailPattern.test(email)); 
// true
```

1. setTimeout()

üëâ Ye function ek delay ke baad code execute karta hai (sirf ek ‡§¨‡§æ‡§∞ ‡§ö‡§≤‡•á‡§ó‡§æ).

Syntax: setTimeout(function, delay, param1, param2, ...);

#Example
console.log("Start");

setTimeout(() => {
    console.log("Hello after 2 seconds");
}, 2000);

console.log("End");

#Start
#End
#Hello after 2 seconds


2. setInterval()

üëâ Ye function ek fixed time interval par bar-bar code execute karta hai.

Syntax:setInterval(function, interval, param1, param2, ...);


let count = 1;

let timer = setInterval(() => {
    console.log("Message " + count);
    count++;
    
    if (count > 5) {
        clearInterval(timer); // Stop after 5 messages
    }
}, 1000); //Message 1 ,Message 2, Message 3, Message 4, Message 5


Class:-
      Class ‡§è‡§ï blueprint ‡§π‡•à, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§π‡§Æ objects ‡§¨‡§®‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§
     Objects ‡§Æ‡•á‡§Ç properties (data) ‡§î‡§∞ methods (functions) ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç‡•§

// Class ‡§¨‡§®‡§æ‡§®‡§æ
class Person {
  constructor(name, age) {
    this.name = name; // property
    this.age = age;   // property
  }

  // Method
  greet() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
}

// Object ‡§¨‡§®‡§æ‡§®‡§æ
let person1 = new Person("Kajal", 22);
person1.greet(); // Output: Hello, my name is Kajal and I am 22 years old.


Explanation:

class Person ‚Üí class ‡§ï‡§æ ‡§®‡§æ‡§Æ Person ‡§π‡•à‡•§
constructor() ‚Üí object ‡§¨‡§®‡§§‡•á ‡§π‡•Ä automatically call ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§
this.name, this.age ‚Üí ‡§Ø‡•á object ‡§ï‡•Ä properties ‡§π‡•à‡§Ç‡•§
greet() ‚Üí ‡§Ø‡•á ‡§è‡§ï method ‡§π‡•à ‡§ú‡§ø‡§∏‡•á object call ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§


Prototype:-

JavaScript ‡§Æ‡•á‡§Ç ‡§π‡§∞ object ‡§ï‡•á ‡§™‡§æ‡§∏ ‡§è‡§ï hidden object ‡§π‡•ã‡§§‡§æ ‡§π‡•à ‡§ú‡§ø‡§∏‡•á prototype ‡§ï‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§
Prototype ‡§Æ‡•á‡§Ç ‡§µ‡•ã methods ‡§î‡§∞ properties ‡§π‡•ã‡§§‡•Ä ‡§π‡•à‡§Ç ‡§ú‡•ã object ‡§ï‡•ã inherited ‡§Æ‡§ø‡§≤‡§§‡•Ä ‡§π‡•à‡§Ç‡•§

Simple words:
Prototype = template ‡§Ø‡§æ parent object ‡§ú‡§ø‡§∏‡§∏‡•á objects feature inherit ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§

function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Prototype method add ‡§ï‡§∞‡§®‡§æ
Person.prototype.greet = function() {
  console.log(`Hello, my name is ${this.name}`);
}

let p1 = new Person("Kajal", 22);
let p2 = new Person("Riya", 20);

p1.greet(); // Hello, my name is Kajal
p2.greet(); // Hello, my name is Riya

important Topic:-
Destructuring ‚Üí Array/Object ‡§ï‡•Ä values ‡§ï‡•ã ‡§Ü‡§∏‡§æ‡§®‡•Ä ‡§∏‡•á extract ‡§ï‡§∞‡§®‡§æ

Spread ‚Üí Array/Object ‡§ï‡•ã expand, copy, merge ‡§ï‡§∞‡§®‡§æ

Rest ‚Üí Function arguments ‡§ï‡•ã array ‡§Æ‡•á‡§Ç collect ‡§ï‡§∞‡§®‡§æ
